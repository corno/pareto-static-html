import * as _et from 'exupery-core-types';
import * as _i_core from "../../../core/resolved";
export type _T_Block_Part = _i_core._T_State_Group<null, readonly ['snippet', string] | readonly ['indent', _T_Group] | readonly ['sub block', _T_Block] | readonly ['optional', _et.Optional_Value<_T_Block_Part>] | readonly ['nothing', null]>;
export type _T_Block = _i_core._T_List<null, _T_Block_Part>;
export type _T_Group_Part = _i_core._T_State_Group<null, readonly ['nested block', _T_Block] | readonly ['block', string] | readonly ['sub group', _T_Group] | readonly ['optional', _et.Optional_Value<_T_Group_Part>] | readonly ['nothing', null]>;
export type _T_Group = _i_core._T_List<null, _T_Group_Part>;
export type _T_Node = _i_core._T_State_Group<null, readonly ['file', _T_Group] | readonly ['directory', _T_Directory]>;
export type _T_Directory = _i_core._T_Dictionary<null, _T_Node>;
export type Block_Part = _T_Block_Part;
export type Block = _T_Block;
export type Group_Part = _T_Group_Part;
export type Group = _T_Group;
export type Node = _T_Node;
export type Directory = _T_Directory;
export declare namespace _T_Block_Part {
    namespace SG {
        type snippet = string;
        namespace indent {
        }
        type indent = _T_Group;
        namespace sub_block {
        }
        type sub_block = _T_Block;
        namespace optional {
            namespace O {
            }
            type O = _T_Block_Part;
        }
        type optional = _et.Optional_Value<_T_Block_Part>;
        type nothing = null;
    }
    type SG = readonly ['snippet', string] | readonly ['indent', _T_Group] | readonly ['sub block', _T_Block] | readonly ['optional', _et.Optional_Value<_T_Block_Part>] | readonly ['nothing', null];
}
export declare namespace _T_Block {
    namespace L {
    }
    type L = _T_Block_Part;
}
export declare namespace _T_Group_Part {
    namespace SG {
        namespace nested_block {
        }
        type nested_block = _T_Block;
        type block = string;
        namespace sub_group {
        }
        type sub_group = _T_Group;
        namespace optional {
            namespace O {
            }
            type O = _T_Group_Part;
        }
        type optional = _et.Optional_Value<_T_Group_Part>;
        type nothing = null;
    }
    type SG = readonly ['nested block', _T_Block] | readonly ['block', string] | readonly ['sub group', _T_Group] | readonly ['optional', _et.Optional_Value<_T_Group_Part>] | readonly ['nothing', null];
}
export declare namespace _T_Group {
    namespace L {
    }
    type L = _T_Group_Part;
}
export declare namespace _T_Node {
    namespace SG {
        namespace file {
        }
        type file = _T_Group;
        namespace directory {
        }
        type directory = _T_Directory;
    }
    type SG = readonly ['file', _T_Group] | readonly ['directory', _T_Directory];
}
export declare namespace _T_Directory {
    namespace D {
    }
    type D = _T_Node;
}
export declare namespace Block_Part {
    namespace SG {
        type snippet = string;
        namespace indent {
        }
        type indent = _T_Group;
        namespace sub_block {
        }
        type sub_block = _T_Block;
        namespace optional {
            namespace O {
            }
            type O = _T_Block_Part;
        }
        type optional = _et.Optional_Value<_T_Block_Part>;
        type nothing = null;
    }
    type SG = readonly ['snippet', string] | readonly ['indent', _T_Group] | readonly ['sub block', _T_Block] | readonly ['optional', _et.Optional_Value<_T_Block_Part>] | readonly ['nothing', null];
}
export declare namespace Block {
    namespace L {
    }
    type L = _T_Block_Part;
}
export declare namespace Group_Part {
    namespace SG {
        namespace nested_block {
        }
        type nested_block = _T_Block;
        type block = string;
        namespace sub_group {
        }
        type sub_group = _T_Group;
        namespace optional {
            namespace O {
            }
            type O = _T_Group_Part;
        }
        type optional = _et.Optional_Value<_T_Group_Part>;
        type nothing = null;
    }
    type SG = readonly ['nested block', _T_Block] | readonly ['block', string] | readonly ['sub group', _T_Group] | readonly ['optional', _et.Optional_Value<_T_Group_Part>] | readonly ['nothing', null];
}
export declare namespace Group {
    namespace L {
    }
    type L = _T_Group_Part;
}
export declare namespace Node {
    namespace SG {
        namespace file {
        }
        type file = _T_Group;
        namespace directory {
        }
        type directory = _T_Directory;
    }
    type SG = readonly ['file', _T_Group] | readonly ['directory', _T_Directory];
}
export declare namespace Directory {
    namespace D {
    }
    type D = _T_Node;
}
