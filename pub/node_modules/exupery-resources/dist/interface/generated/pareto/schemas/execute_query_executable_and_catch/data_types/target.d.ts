import * as _et from 'exupery-core-types';
import * as _i_core from "../../../core/unconstrained";
export type _T_Parameters = {
    readonly 'program': string;
    readonly 'args': _i_core._T_List<null, string>;
};
export type _T_Error = _i_core._T_State_Group<null, readonly [
    'failed to spawn',
    {
        readonly 'message': string;
    }
] | readonly [
    'non zero exit code',
    {
        readonly 'exit code': _et.Optional_Value<number>;
        readonly 'stderr': string;
    }
]>;
export type _T_Result = _i_core._T_State_Group<null, readonly [
    'success',
    {
        readonly 'stdout': string;
    }
] | readonly ['error', _T_Error]>;
export type Parameters = _T_Parameters;
export type Error = _T_Error;
export type Result = _T_Result;
export declare namespace _T_Parameters {
    type program = string;
    namespace args {
        type L = string;
    }
    type args = _i_core._T_List<null, string>;
}
export declare namespace _T_Error {
    namespace SG {
        namespace failed_to_spawn {
            type message = string;
        }
        type failed_to_spawn = {
            readonly 'message': string;
        };
        namespace non_zero_exit_code {
            namespace exit_code {
                type O = number;
            }
            type exit_code = _et.Optional_Value<number>;
            type stderr = string;
        }
        type non_zero_exit_code = {
            readonly 'exit code': _et.Optional_Value<number>;
            readonly 'stderr': string;
        };
    }
    type SG = readonly [
        'failed to spawn',
        {
            readonly 'message': string;
        }
    ] | readonly [
        'non zero exit code',
        {
            readonly 'exit code': _et.Optional_Value<number>;
            readonly 'stderr': string;
        }
    ];
}
export declare namespace _T_Result {
    namespace SG {
        namespace success {
            type stdout = string;
        }
        type success = {
            readonly 'stdout': string;
        };
        namespace error {
        }
        type error = _T_Error;
    }
    type SG = readonly [
        'success',
        {
            readonly 'stdout': string;
        }
    ] | readonly ['error', _T_Error];
}
export declare namespace Parameters {
    type program = string;
    namespace args {
        type L = string;
    }
    type args = _i_core._T_List<null, string>;
}
export declare namespace Error {
    namespace SG {
        namespace failed_to_spawn {
            type message = string;
        }
        type failed_to_spawn = {
            readonly 'message': string;
        };
        namespace non_zero_exit_code {
            namespace exit_code {
                type O = number;
            }
            type exit_code = _et.Optional_Value<number>;
            type stderr = string;
        }
        type non_zero_exit_code = {
            readonly 'exit code': _et.Optional_Value<number>;
            readonly 'stderr': string;
        };
    }
    type SG = readonly [
        'failed to spawn',
        {
            readonly 'message': string;
        }
    ] | readonly [
        'non zero exit code',
        {
            readonly 'exit code': _et.Optional_Value<number>;
            readonly 'stderr': string;
        }
    ];
}
export declare namespace Result {
    namespace SG {
        namespace success {
            type stdout = string;
        }
        type success = {
            readonly 'stdout': string;
        };
        namespace error {
        }
        type error = _T_Error;
    }
    type SG = readonly [
        'success',
        {
            readonly 'stdout': string;
        }
    ] | readonly ['error', _T_Error];
}
