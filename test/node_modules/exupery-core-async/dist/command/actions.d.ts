import * as _et from 'exupery-core-types';
import { Command_Block } from './Command_Block';
export declare namespace p {
    const assert: <Error>(assertion: boolean, error_if_failed: Error) => _et.Command_Promise<Error>;
    namespace deprecated_assert {
        const query: <Error>(assertion: _et.Staging_Result<boolean, Error>, error_if_failed: Error) => _et.Command_Promise<Error>;
    }
    const if_: <Error>(precondition: boolean, command_block: Command_Block<Error>, else_command_block?: Command_Block<Error>) => _et.Command_Promise<Error>;
    namespace deprecated_conditional {
        const query: <Error>(precondition: _et.Staging_Result<boolean, Error>, command: _et.Command_Promise<Error>, else_command?: _et.Command_Promise<Error>) => _et.Command_Promise<Error>;
    }
    namespace list {
        const parallel: <Error, Element_Error>(the_array: _et.List<_et.Command_Promise<Element_Error>>, errors_aggregator: _et.Transformer<Error, _et.List<Element_Error>>) => _et.Command_Promise<Error>;
        const serie: <Error>(array: _et.List<_et.Command_Promise<Error>>) => _et.Command_Promise<Error>;
    }
    namespace dictionary {
        const parallel: <T, Error, Entry_Error>(dictionary: _et.Dictionary<T>, block: (value: T, key: string) => Command_Block<Entry_Error>, aggregate_errors: _et.Transformer<Error, _et.Dictionary<Entry_Error>>) => _et.Command_Promise<Error>;
        namespace deprecated_parallel {
            const query: <T, Error, Entry_Error>(staging_result: _et.Staging_Result<_et.Dictionary<T>, Error>, block: (value: T, key: string) => Command_Block<Entry_Error>, aggregate_errors: _et.Transformer<Error, _et.Dictionary<Entry_Error>>) => _et.Command_Promise<Error>;
        }
        const serie: <Error, Entry_Error>(dictionary: _et.Dictionary<_et.Command_Promise<Entry_Error>>, error_transformer: _et.Transformer<Error, _et.Key_Value_Pair<Entry_Error>>) => _et.Command_Promise<Error>;
        const deprecated_parallel_without_transforming_the_error: <Error, Entry_Error>(dictionary: _et.Dictionary<_et.Command_Promise<Entry_Error>>) => _et.Command_Promise<_et.Dictionary<Entry_Error>>;
    }
    const sequence: <Error>(block: Command_Block<Error>) => _et.Command_Promise<Error>;
    const stage: <Error, Staging_Output>(staging_result: _et.Staging_Result<Staging_Output, Error>, command_block: ($v: Staging_Output) => Command_Block<Error>) => _et.Command_Promise<Error>;
    const stage_stacked: <Error, Staging_Output, Parent_Data>(staging_result: _et.Staging_Result<Staging_Output, Error>, parent_data: Parent_Data, command_block: ($v: Staging_Output, $parent: Parent_Data) => Command_Block<Error>) => _et.Command_Promise<Error>;
}
